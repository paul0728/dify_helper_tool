<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dify Helper Tool - ç¯€é»åŒ¯å…¥åŒ¯å‡ºèˆ‡å°ˆæ¡ˆè½‰æ›</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            border: none;
            background: transparent;
            font-size: 16px;
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .tab-content {
            display: none;
            padding: 30px;
        }

        .tab-content.active {
            display: block;
        }

        .upload-section {
            margin-bottom: 30px;
        }

        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: #f8f9ff;
            margin-bottom: 20px;
            transition: all 0.3s;
        }

        .upload-box:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }

        .upload-box.has-file {
            border-color: #28a745;
            background: #f0fff4;
        }

        .upload-label {
            display: block;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .file-name {
            display: block;
            margin-top: 15px;
            color: #28a745;
            font-weight: 600;
        }

        .graph-container {
            border: 2px solid #e9ecef;
            border-radius: 15px;
            height: 600px;
            margin: 20px 0;
            background: #fafafa;
            position: relative;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .info-box h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .info-box ul {
            margin-left: 20px;
        }

        .info-box li {
            margin: 5px 0;
        }

        .selection-info {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 600;
        }

        .type-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            margin: 10px 0;
        }

        .type-chatflow {
            background: #667eea;
            color: white;
        }

        .type-workflow {
            background: #28a745;
            color: white;
        }

        .conversion-arrow {
            text-align: center;
            font-size: 2em;
            color: #667eea;
            margin: 20px 0;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 600;
        }

        .alert-success {
            background: #d4edda;
            border: 2px solid #28a745;
            color: #155724;
        }

        .alert-error {
            background: #f8d7da;
            border: 2px solid #dc3545;
            color: #721c24;
        }

        .alert-info {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            color: #0c5460;
        }

        #cy {
            width: 100%;
            height: 100%;
            border-radius: 15px;
        }
        
        #cy canvas {
            outline: none;
        }

        .node-list {
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            background: #fafafa;
        }

        .node-item {
            display: flex;
            align-items: center;
            padding: 12px;
            margin: 8px 0;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .node-item:hover {
            border-color: #667eea;
            transform: translateX(5px);
        }

        .node-item.selected {
            background: #d4edda;
            border-color: #28a745;
        }

        .node-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            cursor: pointer;
        }

        .node-info {
            flex: 1;
        }

        .node-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .node-type {
            font-size: 0.9em;
            color: #6c757d;
        }

        .node-id {
            font-size: 0.85em;
            color: #999;
            margin-left: 10px;
        }

        .edge-list {
            max-height: 300px;
            overflow-y: auto;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            background: #fafafa;
        }

        .edge-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin: 6px 0;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .edge-item:hover {
            border-color: #667eea;
        }

        .edge-item.selected {
            background: #fff3cd;
            border-color: #ffc107;
        }

        .edge-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 12px;
            cursor: pointer;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0 10px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .section-header h3 {
            color: #667eea;
            margin: 0;
        }

        .section-controls {
            display: flex;
            gap: 10px;
        }

        .btn-sm {
            padding: 6px 15px;
            font-size: 0.9em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .stat-card p {
            opacity: 0.9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .footer {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            color: #6c757d;
            border-top: 2px solid #e9ecef;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ Dify Helper Tool</h1>
            <p>ç¯€é»åŒ¯å…¥åŒ¯å‡ºèˆ‡å°ˆæ¡ˆé¡å‹è½‰æ›å·¥å…·</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('import')">ğŸ“¥ ç¯€é»åŒ¯å…¥åŒ¯å‡º</button>
            <button class="tab" onclick="switchTab('convert')">ğŸ”„ å°ˆæ¡ˆé¡å‹è½‰æ›</button>
        </div>

        <!-- ç¯€é»åŒ¯å…¥åŒ¯å‡º Tab -->
        <div id="import-tab" class="tab-content active">
            <div class="info-box">
                <h3>ğŸ“– ä½¿ç”¨èªªæ˜</h3>
                <ul>
                    <li>ä¸Šå‚³ä¾†æº DSL æª”æ¡ˆï¼ˆåŒ…å«è¦åŒ¯å…¥çš„ç¯€é»ï¼‰</li>
                    <li>ä¸Šå‚³ç›®æ¨™ DSL æª”æ¡ˆï¼ˆè¦è¢«åŒ¯å…¥çš„å°ˆæ¡ˆï¼‰</li>
                    <li>åœ¨åœ–å½¢ä¸­é¸æ“‡è¦åŒ¯å…¥çš„ç¯€é»ï¼ˆé è¨­å…¨é¸ï¼‰</li>
                    <li>é»æ“Šã€ŒåŸ·è¡ŒåŒ¯å…¥ã€å®Œæˆç¯€é»åŒ¯å…¥</li>
                </ul>
            </div>

            <div class="upload-section">
                <div class="upload-box" id="source-upload-box">
                    <span class="upload-label">ä¾†æºæª”æ¡ˆï¼ˆSource DSLï¼‰</span>
                    <label for="source-file" class="file-input-label">é¸æ“‡æª”æ¡ˆ</label>
                    <input type="file" id="source-file" accept=".yml,.yaml" onchange="handleSourceFile(event)">
                    <span class="file-name" id="source-file-name"></span>
                </div>

                <div class="upload-box" id="target-upload-box">
                    <span class="upload-label">ç›®æ¨™æª”æ¡ˆï¼ˆTarget DSLï¼‰</span>
                    <label for="target-file" class="file-input-label">é¸æ“‡æª”æ¡ˆ</label>
                    <input type="file" id="target-file" accept=".yml,.yaml" onchange="handleTargetFile(event)">
                    <span class="file-name" id="target-file-name"></span>
                </div>
            </div>

            <div id="graph-section" style="display: none;">
                <!-- çµ±è¨ˆä¿¡æ¯ -->
                <div class="selection-info" id="selection-info">
                    å·²é¸æ“‡: <span id="selected-nodes-count">0</span> å€‹ç¯€é» + <span id="selected-edges-count">0</span> æ¢é€£æ¥ / 
                    å…± <span id="total-nodes-count">0</span> å€‹ç¯€é» + <span id="total-edges-count">0</span> æ¢é€£æ¥
                </div>
                
                <!-- å…¨é¸/å…¨ä¸é¸/é‡ç½®è¦–åœ– æŒ‰éˆ• -->
                <div class="controls">
                    <button class="btn btn-primary" onclick="selectAllItems()">âœ“ å…¨é¸ï¼ˆç¯€é»+é€£æ¥ï¼‰</button>
                    <button class="btn btn-secondary" onclick="deselectAllItems()">âœ— å…¨ä¸é¸</button>
                    <button class="btn btn-secondary" onclick="resetGraphView()">ğŸ”„ é‡ç½®è¦–åœ–</button>
                </div>

                <!-- è¦–è¦ºåŒ–çµæ§‹åœ– -->
                <div class="section-header">
                    <h3>ğŸ—ºï¸ è¦–è¦ºåŒ–çµæ§‹åœ–ï¼ˆæ©«å‘é¡¯ç¤ºï¼‰</h3>
                    <div class="section-controls">
                        <span style="font-size: 0.9em; color: #6c757d;">
                            ğŸ’¡ å·¦éµé»æ“Šï¼šåˆ‡æ›å–®å€‹å…ƒç´  | å·¦éµæ‹–å‹•æ¡†é¸ï¼šé¸æ“‡æ¡†å…§å…ƒç´  | å³éµæ‹–å‹•ï¼šç§»å‹•ç•«å¸ƒ | æ»¾è¼ªï¼šç¸®æ”¾
                        </span>
                    </div>
                </div>
                <div class="graph-container">
                    <div id="cy"></div>
                </div>

                <!-- ç¯€é»åˆ—è¡¨ -->
                <div class="section-header">
                    <h3>ğŸ“¦ ç¯€é»åˆ—è¡¨</h3>
                    <div class="section-controls">
                        <button class="btn btn-primary btn-sm" onclick="selectAllNodes()">âœ“ å…¨é¸ç¯€é»</button>
                        <button class="btn btn-secondary btn-sm" onclick="deselectAllNodes()">âœ— æ¸…é™¤ç¯€é»</button>
                    </div>
                </div>
                <div class="node-list" id="node-list"></div>

                <!-- é€£æ¥åˆ—è¡¨ -->
                <div class="section-header">
                    <h3>ğŸ”— é€£æ¥åˆ—è¡¨</h3>
                    <div class="section-controls">
                        <button class="btn btn-primary btn-sm" onclick="selectAllEdges()">âœ“ å…¨é¸é€£æ¥</button>
                        <button class="btn btn-secondary btn-sm" onclick="deselectAllEdges()">âœ— æ¸…é™¤é€£æ¥</button>
                    </div>
                </div>
                <div class="edge-list" id="edge-list"></div>

                <!-- åŸ·è¡ŒåŒ¯å…¥æŒ‰éˆ• -->
                <div class="controls" style="justify-content: center; margin-top: 30px;">
                    <button class="btn btn-success" onclick="executeImport()" id="import-btn" disabled style="font-size: 1.1em; padding: 15px 50px;">ğŸ“¥ åŸ·è¡ŒåŒ¯å…¥</button>
                </div>
            </div>

            <div id="import-result"></div>
        </div>

        <!-- å°ˆæ¡ˆé¡å‹è½‰æ› Tab -->
        <div id="convert-tab" class="tab-content">
            <div class="info-box">
                <h3>ğŸ“– ä½¿ç”¨èªªæ˜</h3>
                <ul>
                    <li>ä¸Šå‚³ DSL æª”æ¡ˆï¼ˆChatflow æˆ– Workflowï¼‰</li>
                    <li>ç³»çµ±è‡ªå‹•åµæ¸¬å°ˆæ¡ˆé¡å‹</li>
                    <li>é»æ“Šã€Œè½‰æ›é¡å‹ã€æŒ‰éˆ•é€²è¡Œè½‰æ›</li>
                    <li>ä¸‹è¼‰è½‰æ›å¾Œçš„ DSL æª”æ¡ˆ</li>
                </ul>
            </div>

            <div class="info-box">
                <h3>ğŸ” è½‰æ›èªªæ˜</h3>
                <ul>
                    <li><strong>Chatflow â†’ Workflow:</strong> answer ç¯€é» â†’ end ç¯€é», sys.query â†’ query</li>
                    <li><strong>Workflow â†’ Chatflow:</strong> end ç¯€é» â†’ answer ç¯€é», query â†’ sys.query</li>
                    <li>è‡ªå‹•è™•ç† sys.dialogue_countã€sys.conversation_id ç­‰è®Šæ•¸</li>
                </ul>
            </div>

            <div class="upload-section">
                <div class="upload-box" id="convert-upload-box">
                    <span class="upload-label">ä¸Šå‚³ DSL æª”æ¡ˆ</span>
                    <label for="convert-file" class="file-input-label">é¸æ“‡æª”æ¡ˆ</label>
                    <input type="file" id="convert-file" accept=".yml,.yaml" onchange="handleConvertFile(event)">
                    <span class="file-name" id="convert-file-name"></span>
                </div>
            </div>

            <div id="convert-info" style="display: none;">
                <div class="stats">
                    <div class="stat-card">
                        <h3 id="node-count">0</h3>
                        <p>ç¯€é»æ•¸é‡</p>
                    </div>
                    <div class="stat-card">
                        <h3 id="edge-count">0</h3>
                        <p>é€£æ¥æ•¸é‡</p>
                    </div>
                </div>

                <div style="text-align: center; margin: 30px 0;">
                    <div>
                        <span class="type-badge" id="current-type">-</span>
                    </div>
                    <div class="conversion-arrow">â¬‡ï¸</div>
                    <button class="btn btn-warning btn-lg" onclick="convertType()" id="convert-btn" style="font-size: 1.2em; padding: 15px 40px;">
                        ğŸ”„ è½‰æ›é¡å‹
                    </button>
                    <div class="conversion-arrow">â¬‡ï¸</div>
                    <div>
                        <span class="type-badge" id="target-type">-</span>
                    </div>
                </div>

                <div class="controls" style="justify-content: center;">
                    <button class="btn btn-success" onclick="downloadConverted()" id="download-btn" disabled style="font-size: 1.1em; padding: 15px 40px;">
                        ğŸ’¾ ä¸‹è¼‰è½‰æ›å¾Œçš„æª”æ¡ˆ
                    </button>
                </div>
            </div>

            <div id="convert-result"></div>
        </div>

        <div class="footer">
            <p>Made with â¤ï¸ for Dify Users | Â© 2024</p>
        </div>
    </div>

    <script>
        let sourceData = null;
        let targetData = null;
        let convertData = null;
        let convertedData = null;
        let cy = null;
        let selectedNodes = new Set();
        let selectedEdges = new Set();
        let nodeMap = new Map();
        let edgeMap = new Map();
        let isBoxSelecting = false;

        // Tab åˆ‡æ›
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // è™•ç†ä¾†æºæª”æ¡ˆ
        function handleSourceFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    sourceData = jsyaml.load(e.target.result);
                    document.getElementById('source-file-name').textContent = `âœ“ ${file.name}`;
                    document.getElementById('source-upload-box').classList.add('has-file');
                    
                    if (targetData) {
                        renderGraph();
                    }
                } catch (error) {
                    showAlert('import-result', 'error', 'éŒ¯èª¤ï¼šç„¡æ³•è§£æä¾†æºæª”æ¡ˆï¼' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // è™•ç†ç›®æ¨™æª”æ¡ˆ
        function handleTargetFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    targetData = jsyaml.load(e.target.result);
                    document.getElementById('target-file-name').textContent = `âœ“ ${file.name}`;
                    document.getElementById('target-upload-box').classList.add('has-file');
                    
                    if (sourceData) {
                        renderGraph();
                    }
                } catch (error) {
                    showAlert('import-result', 'error', 'éŒ¯èª¤ï¼šç„¡æ³•è§£æç›®æ¨™æª”æ¡ˆï¼' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // æ¸²æŸ“åœ–å½¢
        function renderGraph() {
            document.getElementById('graph-section').style.display = 'block';
            
            // éæ¿¾æ‰ start ç¯€é»
            const filteredNodes = sourceData.workflow.graph.nodes.filter(node => 
                node.data.type !== 'start'
            );

            // éæ¿¾æ‰èˆ‡ start ç¯€é»ç›¸é—œçš„é‚Š
            const startNodeIds = sourceData.workflow.graph.nodes
                .filter(node => node.data.type === 'start')
                .map(node => node.id);
            
            const filteredEdges = sourceData.workflow.graph.edges.filter(edge => 
                !startNodeIds.includes(edge.source) && !startNodeIds.includes(edge.target)
            );

            // æ¸…ç©ºä¸¦é‡å»ºæ˜ å°„
            nodeMap.clear();
            edgeMap.clear();
            filteredNodes.forEach(node => nodeMap.set(node.id, node));
            filteredEdges.forEach(edge => edgeMap.set(edge.id, edge));

            // æ¸²æŸ“ç¯€é»åˆ—è¡¨
            renderNodeList(filteredNodes);
            
            // æ¸²æŸ“é€£æ¥åˆ—è¡¨
            renderEdgeList(filteredEdges);

            // å‰µå»º Cytoscape åœ–å½¢
            const nodes = filteredNodes.map(node => ({
                data: {
                    id: node.id,
                    label: `${node.data.title || node.data.type}\n(${node.data.type})`
                }
            }));

            const edges = filteredEdges.map(edge => ({
                data: {
                    id: edge.id,
                    source: edge.source,
                    target: edge.target
                }
            }));

            if (cy) {
                cy.destroy();
            }

            // è¨»å†Š dagre ä½ˆå±€
            if (typeof cytoscape !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {
                try {
                    cytoscape.use(cytoscapeDagre);
                } catch (e) {
                    console.log('Dagre already registered or error:', e);
                }
            }

            cy = cytoscape({
                container: document.getElementById('cy'),
                elements: [...nodes, ...edges],
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': '#667eea',
                            'label': 'data(label)',
                            'text-valign': 'center',
                            'text-halign': 'center',
                            'color': '#fff',
                            'text-outline-width': 2,
                            'text-outline-color': '#667eea',
                            'width': 50,
                            'height': 50,
                            'font-size': 8,
                            'text-wrap': 'wrap',
                            'text-max-width': 45
                        }
                    },
                    {
                        selector: 'node.selected-node',
                        style: {
                            'background-color': '#28a745',
                            'border-width': 3,
                            'border-color': '#155724',
                            'text-outline-color': '#28a745'
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': '#999',
                            'target-arrow-color': '#999',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier'
                        }
                    },
                    {
                        selector: 'edge.selected-edge',
                        style: {
                            'width': 4,
                            'line-color': '#ffc107',
                            'target-arrow-color': '#ffc107'
                        }
                    }
                ],
                layout: {
                    name: 'dagre',
                    rankDir: 'LR',
                    nodeSep: 80,
                    rankSep: 120,
                    padding: 30
                },
                boxSelectionEnabled: true,
                selectionType: 'additive',
                autoungrabify: true,
                autounselectify: false,
                userZoomingEnabled: true,
                userPanningEnabled: false,
                minZoom: 0.3,
                maxZoom: 3
            });

            // é è¨­å…¨é¸
            filteredNodes.forEach(node => selectedNodes.add(node.id));
            filteredEdges.forEach(edge => selectedEdges.add(edge.id));
            updateGraphSelection();
            updateNodeListSelection();
            updateEdgeListSelection();

            // === ä¿®å¾©ï¼šå·¦éµé»æ“Šç¯€é» ===
            cy.on('tap', 'node', function(evt) {
                if (isBoxSelecting) return; // æ¡†é¸æ™‚ä¸è™•ç†é»æ“Š
                const node = evt.target;
                const nodeId = node.id();
                console.log('Node clicked:', nodeId);
                toggleNodeSelection(nodeId);
            });

            // === ä¿®å¾©ï¼šå·¦éµé»æ“Šé‚Š ===
            cy.on('tap', 'edge', function(evt) {
                if (isBoxSelecting) return; // æ¡†é¸æ™‚ä¸è™•ç†é»æ“Š
                const edge = evt.target;
                const edgeId = edge.id();
                console.log('Edge clicked:', edgeId);
                toggleEdgeSelection(edgeId);
            });

            // === ä¿®å¾©ï¼šæ¡†é¸é–‹å§‹ ===
            cy.on('boxstart', function(evt) {
                isBoxSelecting = true;
                console.log('Box selection started');
            });

            // === ä¿®å¾©ï¼šæ¡†é¸çµæŸ - æ”¹ç‚ºæ›¿æ›å¼é¸æ“‡ ===
            cy.on('boxend', function(evt) {
                console.log('Box selection ended');
                
                // ä½¿ç”¨ setTimeout ç¢ºä¿ Cytoscape å·²å®Œæˆå…§éƒ¨é¸æ“‡æ›´æ–°
                setTimeout(() => {
                    // ç²å–æ¡†é¸åˆ°çš„å…ƒç´ 
                    const boxSelected = cy.$(':selected');
                    
                    console.log('Boxed elements count:', boxSelected.length);
                    
                    if (boxSelected.length === 0) {
                        console.log('No elements in box, keeping current selection');
                        isBoxSelecting = false;
                        return;
                    }
                    
                    // æ¸…ç©ºç•¶å‰é¸æ“‡
                    selectedNodes.clear();
                    selectedEdges.clear();
                    
                    // æ·»åŠ æ¡†é¸çš„ç¯€é»
                    boxSelected.nodes().forEach(node => {
                        const nodeId = node.id();
                        selectedNodes.add(nodeId);
                        console.log('Selected node:', nodeId);
                    });
                    
                    // æ·»åŠ æ¡†é¸çš„é‚Š
                    boxSelected.edges().forEach(edge => {
                        const edgeId = edge.id();
                        selectedEdges.add(edgeId);
                        console.log('Selected edge:', edgeId);
                    });
                    
                    console.log('Final selection - Nodes:', selectedNodes.size, 'Edges:', selectedEdges.size);
                    
                    // æ¸…é™¤ Cytoscape çš„å…§å»ºé¸æ“‡ä¸¦æ›´æ–°é¡¯ç¤º
                    cy.$(':selected').unselect();
                    updateGraphSelection();
                    updateNodeListSelection();
                    updateEdgeListSelection();
                    updateSelectionInfo();
                    isBoxSelecting = false;
                }, 50);  // å¢åŠ å»¶é²åˆ° 50ms ç¢ºä¿ç©©å®šæ€§
            });

            // å³éµå¹³ç§»åŠŸèƒ½
            let isPanning = false;
            let panStartPos = { x: 0, y: 0 };
            let panStartPan = { x: 0, y: 0 };
            const container = cy.container();

            container.addEventListener('mousedown', function(evt) {
                if (evt.button === 2) { // å³éµ
                    isPanning = true;
                    container.style.cursor = 'grabbing';
                    const pan = cy.pan();
                    panStartPos = { x: evt.clientX, y: evt.clientY };
                    panStartPan = { x: pan.x, y: pan.y };
                    evt.preventDefault();
                }
            });

            container.addEventListener('mousemove', function(evt) {
                if (isPanning) {
                    const dx = evt.clientX - panStartPos.x;
                    const dy = evt.clientY - panStartPos.y;
                    cy.pan({
                        x: panStartPan.x + dx,
                        y: panStartPan.y + dy
                    });
                    evt.preventDefault();
                }
            });

            container.addEventListener('mouseup', function(evt) {
                if (evt.button === 2) { // å³éµ
                    isPanning = false;
                    container.style.cursor = 'default';
                }
            });

            // ç¦ç”¨å³éµé¸å–®
            container.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                return false;
            });

            // === ä¿®å¾©ï¼šå•Ÿç”¨æ»¾è¼ªç¸®æ”¾ ===
            container.addEventListener('wheel', function(e) {
                e.preventDefault();  // é˜»æ­¢ç€è¦½å™¨æ»¾å‹•
                e.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡
                
                // Cytoscape æœƒè‡ªå‹•è™•ç†ç¸®æ”¾
                const delta = e.deltaY;
                const zoom = cy.zoom();
                const zoomFactor = delta > 0 ? 0.95 : 1.05; // å‘ä¸‹æ»¾ï¼šç¸®å°ï¼Œå‘ä¸Šæ»¾ï¼šæ”¾å¤§
                
                // ä»¥æ»‘é¼ ä½ç½®ç‚ºä¸­å¿ƒç¸®æ”¾
                const container = cy.container();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                cy.zoom({
                    level: zoom * zoomFactor,
                    position: { x: mouseX, y: mouseY }
                });
            }, { passive: false });  // passive: false ç¢ºä¿ preventDefault æœ‰æ•ˆ

            // æ»‘é¼ ç§»åˆ°ç¯€é»æˆ–é‚Šä¸Šæ™‚æ”¹è®Šæ¸¸æ¨™
            cy.on('mouseover', 'node, edge', function() {
                if (!isPanning) {
                    container.style.cursor = 'pointer';
                }
            });

            cy.on('mouseout', 'node, edge', function() {
                if (!isPanning) {
                    container.style.cursor = 'default';
                }
            });

            updateSelectionInfo();
            initializeGraphView();
        }

        // æ¸²æŸ“ç¯€é»åˆ—è¡¨
        function renderNodeList(nodes) {
            const listHtml = nodes.map(node => `
                <div class="node-item ${selectedNodes.has(node.id) ? 'selected' : ''}" 
                     onclick="toggleNodeSelectionFromList('${node.id}')" 
                     id="node-item-${node.id}">
                    <input type="checkbox" 
                           ${selectedNodes.has(node.id) ? 'checked' : ''} 
                           onchange="toggleNodeSelectionFromList('${node.id}')"
                           onclick="event.stopPropagation()">
                    <div class="node-info">
                        <div class="node-title">${node.data.title || 'æœªå‘½åç¯€é»'}</div>
                        <div class="node-type">é¡å‹: ${node.data.type}<span class="node-id">ID: ${node.id}</span></div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('node-list').innerHTML = listHtml;
        }

        // æ¸²æŸ“é€£æ¥åˆ—è¡¨
        function renderEdgeList(edges) {
            const listHtml = edges.map(edge => {
                const sourceNode = nodeMap.get(edge.source);
                const targetNode = nodeMap.get(edge.target);
                const sourceTitle = sourceNode ? (sourceNode.data.title || sourceNode.data.type) : edge.source;
                const targetTitle = targetNode ? (targetNode.data.title || targetNode.data.type) : edge.target;
                
                return `
                    <div class="edge-item ${selectedEdges.has(edge.id) ? 'selected' : ''}" 
                         onclick="toggleEdgeSelectionFromList('${edge.id}')"
                         id="edge-item-${edge.id}">
                        <input type="checkbox" 
                               ${selectedEdges.has(edge.id) ? 'checked' : ''} 
                               onchange="toggleEdgeSelectionFromList('${edge.id}')"
                               onclick="event.stopPropagation()">
                        <div class="node-info">
                            <strong>${sourceTitle}</strong> â†’ <strong>${targetTitle}</strong>
                            <span class="node-id">ID: ${edge.id}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('edge-list').innerHTML = listHtml;
        }

        // åˆ‡æ›ç¯€é»é¸å–ï¼ˆå¾åˆ—è¡¨ï¼‰
        function toggleNodeSelectionFromList(nodeId) {
            toggleNodeSelection(nodeId);
        }

        // åˆ‡æ›é‚Šé¸å–ï¼ˆå¾åˆ—è¡¨ï¼‰
        function toggleEdgeSelectionFromList(edgeId) {
            toggleEdgeSelection(edgeId);
        }

        // åˆ‡æ›ç¯€é»é¸å–
        function toggleNodeSelection(nodeId) {
            if (selectedNodes.has(nodeId)) {
                selectedNodes.delete(nodeId);
                console.log('Deselected node:', nodeId);
            } else {
                selectedNodes.add(nodeId);
                console.log('Selected node:', nodeId);
            }
            updateGraphSelection();
            updateNodeListSelection();
            updateSelectionInfo();
        }

        // åˆ‡æ›é‚Šé¸å–
        function toggleEdgeSelection(edgeId) {
            if (selectedEdges.has(edgeId)) {
                selectedEdges.delete(edgeId);
                console.log('Deselected edge:', edgeId);
            } else {
                selectedEdges.add(edgeId);
                console.log('Selected edge:', edgeId);
            }
            updateGraphSelection();
            updateEdgeListSelection();
            updateSelectionInfo();
        }

        // æ›´æ–°åœ–å½¢é¸å–ç‹€æ…‹
        function updateGraphSelection() {
            if (!cy) return;
            
            // æ¸…é™¤æ‰€æœ‰æ¨£å¼
            cy.nodes().removeClass('selected-node');
            cy.edges().removeClass('selected-edge');
            
            // æ‡‰ç”¨é¸ä¸­æ¨£å¼
            selectedNodes.forEach(nodeId => {
                const node = cy.getElementById(nodeId);
                if (node.length > 0) {
                    node.addClass('selected-node');
                }
            });
            
            selectedEdges.forEach(edgeId => {
                const edge = cy.getElementById(edgeId);
                if (edge.length > 0) {
                    edge.addClass('selected-edge');
                }
            });
        }

        // æ›´æ–°ç¯€é»åˆ—è¡¨é¸å–ç‹€æ…‹
        function updateNodeListSelection() {
            nodeMap.forEach((node, nodeId) => {
                const item = document.getElementById(`node-item-${nodeId}`);
                const checkbox = item?.querySelector('input[type="checkbox"]');
                if (item && checkbox) {
                    if (selectedNodes.has(nodeId)) {
                        item.classList.add('selected');
                        checkbox.checked = true;
                    } else {
                        item.classList.remove('selected');
                        checkbox.checked = false;
                    }
                }
            });
        }

        // æ›´æ–°é‚Šåˆ—è¡¨é¸å–ç‹€æ…‹
        function updateEdgeListSelection() {
            edgeMap.forEach((edge, edgeId) => {
                const item = document.getElementById(`edge-item-${edgeId}`);
                const checkbox = item?.querySelector('input[type="checkbox"]');
                if (item && checkbox) {
                    if (selectedEdges.has(edgeId)) {
                        item.classList.add('selected');
                        checkbox.checked = true;
                    } else {
                        item.classList.remove('selected');
                        checkbox.checked = false;
                    }
                }
            });
        }

        // æ›´æ–°é¸æ“‡è³‡è¨Š
        function updateSelectionInfo() {
            const selectedNodesCount = selectedNodes.size;
            const selectedEdgesCount = selectedEdges.size;
            const totalNodesCount = nodeMap.size;
            const totalEdgesCount = edgeMap.size;
            
            document.getElementById('selected-nodes-count').textContent = selectedNodesCount;
            document.getElementById('selected-edges-count').textContent = selectedEdgesCount;
            document.getElementById('total-nodes-count').textContent = totalNodesCount;
            document.getElementById('total-edges-count').textContent = totalEdgesCount;
            document.getElementById('import-btn').disabled = selectedNodesCount === 0 && selectedEdgesCount === 0;
        }

        // å…¨é¸æ‰€æœ‰é …ç›®
        function selectAllItems() {
            selectAllNodes();
            selectAllEdges();
        }

        // å…¨ä¸é¸æ‰€æœ‰é …ç›®
        function deselectAllItems() {
            deselectAllNodes();
            deselectAllEdges();
        }

        // å…¨é¸ç¯€é»
        function selectAllNodes() {
            nodeMap.forEach((node, nodeId) => selectedNodes.add(nodeId));
            updateGraphSelection();
            updateNodeListSelection();
            updateSelectionInfo();
        }

        // å…¨ä¸é¸ç¯€é»
        function deselectAllNodes() {
            selectedNodes.clear();
            updateGraphSelection();
            updateNodeListSelection();
            updateSelectionInfo();
        }

        // å…¨é¸é‚Š
        function selectAllEdges() {
            edgeMap.forEach((edge, edgeId) => selectedEdges.add(edgeId));
            updateGraphSelection();
            updateEdgeListSelection();
            updateSelectionInfo();
        }

        // å…¨ä¸é¸é‚Š
        function deselectAllEdges() {
            selectedEdges.clear();
            updateGraphSelection();
            updateEdgeListSelection();
            updateSelectionInfo();
        }

        // é‡ç½®åœ–å½¢è¦–åœ–
        function resetGraphView() {
            if (cy) {
                cy.fit(50);
                cy.center();
            }
        }

        // åˆå§‹åŒ–å®Œæˆå¾Œè‡ªå‹•èª¿æ•´è¦–åœ–
        function initializeGraphView() {
            if (cy) {
                setTimeout(() => {
                    cy.fit(50);
                    cy.center();
                }, 100);
            }
        }

        // åŸ·è¡ŒåŒ¯å…¥
        function executeImport() {
            if (!sourceData || !targetData || (selectedNodes.size === 0 && selectedEdges.size === 0)) {
                showAlert('import-result', 'error', 'è«‹ç¢ºèªå·²é¸æ“‡ç¯€é»/é€£æ¥ä¸¦ä¸Šå‚³ä¾†æºå’Œç›®æ¨™æª”æ¡ˆï¼');
                return;
            }

            try {
                // æ·±åº¦è¤‡è£½ç›®æ¨™æ•¸æ“šï¼Œé¿å…ä¿®æ”¹åŸå§‹å°è±¡
                const resultData = JSON.parse(JSON.stringify(targetData));
                
                // ç¢ºä¿å¿…è¦çµæ§‹å­˜åœ¨
                if (!resultData.workflow) {
                    resultData.workflow = { graph: { nodes: [], edges: [] } };
                }
                if (!resultData.workflow.graph) {
                    resultData.workflow.graph = { nodes: [], edges: [] };
                }
                if (!resultData.workflow.graph.nodes) {
                    resultData.workflow.graph.nodes = [];
                }
                if (!resultData.workflow.graph.edges) {
                    resultData.workflow.graph.edges = [];
                }

                // åˆ¤æ–·ä¾†æºå’Œç›®æ¨™çš„é¡å‹
                const sourceIsChatflow = sourceData.app.mode === 'advanced-chat';
                const targetIsWorkflow = resultData.app.mode === 'workflow';
                const needsConversion = sourceIsChatflow && targetIsWorkflow;

                // ç²å–è¦åŒ¯å…¥çš„ç¯€é»ï¼ˆæ·±åº¦è¤‡è£½ï¼Œæ’é™¤ start ç¯€é»ï¼‰
                const nodesToImport = Array.from(selectedNodes)
                    .map(nodeId => {
                        const node = nodeMap.get(nodeId);
                        if (node && node.data.type !== 'start') {
                            return JSON.parse(JSON.stringify(node));
                        }
                        return null;
                    })
                    .filter(node => node !== null);
                
                // å¦‚æœéœ€è¦è½‰æ›ï¼Œè™•ç† answer â†’ end
                if (needsConversion) {
                    nodesToImport.forEach(node => {
                        if (node.data.type === 'answer') {
                            node.data.type = 'end';
                            node.type = 'custom';
                            
                            // è½‰æ›è¼¸å‡ºæ ¼å¼
                            if (node.data.answer) {
                                const selector = parseVariableSelector(node.data.answer);
                                node.data.outputs = [{
                                    value_selector: selector,
                                    value_type: 'string',
                                    variable: selector.length > 0 ? selector[selector.length - 1] : 'result'
                                }];
                                delete node.data.answer;
                            } else {
                                node.data.outputs = [{
                                    value_selector: [],
                                    value_type: 'string',
                                    variable: 'result'
                                }];
                            }
                            
                            delete node.data.variables;
                            
                            if (node.data.selected === undefined) {
                                node.data.selected = false;
                            }
                        }
                    });
                }

                // ç²å–è¦åŒ¯å…¥çš„é‚Šï¼ˆæ·±åº¦è¤‡è£½ï¼‰
                const edgesToImport = Array.from(selectedEdges)
                    .map(edgeId => {
                        const edge = edgeMap.get(edgeId);
                        if (edge) {
                            return JSON.parse(JSON.stringify(edge));
                        }
                        return null;
                    })
                    .filter(edge => edge !== null);
                
                // å¦‚æœéœ€è¦è½‰æ›ï¼Œè™•ç† edges ä¸­çš„ answer â†’ end
                if (needsConversion) {
                    edgesToImport.forEach(edge => {
                        if (edge.data) {
                            if (edge.data.targetType === 'answer') {
                                edge.data.targetType = 'end';
                            }
                            if (edge.data.sourceType === 'answer') {
                                edge.data.sourceType = 'end';
                            }
                        }
                    });
                }

                // å»ºç«‹ç¾æœ‰ ID é›†åˆ
                const existingNodeIds = new Set(resultData.workflow.graph.nodes.map(n => n.id));
                const existingEdgeIds = new Set(resultData.workflow.graph.edges.map(e => e.id));
                const nodeIdMap = new Map();

                // è™•ç†ç¯€é» ID è¡çª
                nodesToImport.forEach(node => {
                    const originalId = node.id;
                    let newId = originalId;
                    
                    // å¦‚æœ ID è¡çªï¼Œç”Ÿæˆæ–° ID
                    if (existingNodeIds.has(newId)) {
                        const timestamp = Date.now();
                        const random = Math.random().toString(36).substring(2, 9);
                        newId = `${originalId}_${timestamp}_${random}`;
                        nodeIdMap.set(originalId, newId);
                        node.id = newId;
                    }
                    
                    // ç¢ºä¿ç¯€é»æœ‰æ‰€æœ‰å¿…è¦å±¬æ€§
                    if (!node.data) {
                        node.data = {};
                    }
                    if (!node.data.selected) {
                        node.data.selected = false;
                    }
                    
                    // æ·»åŠ åˆ°çµæœ
                    resultData.workflow.graph.nodes.push(node);
                    existingNodeIds.add(newId);
                });

                // è™•ç†é‚Š
                edgesToImport.forEach(edge => {
                    const originalId = edge.id;
                    const originalSource = edge.source;
                    const originalTarget = edge.target;
                    
                    // æ›´æ–° source å’Œ targetï¼ˆå¦‚æœå®ƒå€‘çš„ç¯€é» ID è¢«é‡æ–°å‘½åï¼‰
                    if (nodeIdMap.has(originalSource)) {
                        edge.source = nodeIdMap.get(originalSource);
                    }
                    if (nodeIdMap.has(originalTarget)) {
                        edge.target = nodeIdMap.get(originalTarget);
                    }
                    
                    // è™•ç† edge ID è¡çª
                    let newEdgeId = originalId;
                    if (existingEdgeIds.has(newEdgeId)) {
                        const timestamp = Date.now();
                        const random = Math.random().toString(36).substring(2, 9);
                        newEdgeId = `${originalId}_${timestamp}_${random}`;
                        edge.id = newEdgeId;
                    }
                    
                    // ç¢ºä¿é‚Šæœ‰æ‰€æœ‰å¿…è¦å±¬æ€§
                    if (!edge.data) {
                        edge.data = {};
                    }
                    if (!edge.type) {
                        edge.type = 'custom';
                    }
                    if (edge.selected === undefined) {
                        edge.selected = false;
                    }
                    if (edge.zIndex === undefined) {
                        edge.zIndex = 0;
                    }
                    
                    // æ·»åŠ åˆ°çµæœ
                    resultData.workflow.graph.edges.push(edge);
                    existingEdgeIds.add(newEdgeId);
                });

                // ç”Ÿæˆ YAML
                const yamlStr = jsyaml.dump(resultData, {
                    indent: 2,
                    lineWidth: -1,
                    noRefs: true,
                    sortKeys: false
                });
                
                const targetType = resultData.app.mode === 'advanced-chat' ? 'chatflow' : 'workflow';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                downloadFile(yamlStr, `imported_${targetType}_${timestamp}.yml`);

                showAlert('import-result', 'success', 
                    `âœ“ æˆåŠŸåŒ¯å…¥ ${nodesToImport.length} å€‹ç¯€é»å’Œ ${edgesToImport.length} æ¢é€£æ¥ï¼${nodeIdMap.size > 0 ? `<br>ï¼ˆ${nodeIdMap.size} å€‹ç¯€é»å›  ID è¡çªå·²é‡æ–°å‘½åï¼‰` : ''}`);
            } catch (error) {
                console.error('Import error:', error);
                showAlert('import-result', 'error', 'åŒ¯å…¥å¤±æ•—ï¼š' + error.message + '<br>è«‹æª¢æŸ¥æ§åˆ¶å°ä»¥ç²å–æ›´å¤šè³‡è¨Šã€‚');
            }
        }

        // è™•ç†è½‰æ›æª”æ¡ˆ
        function handleConvertFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    convertData = jsyaml.load(e.target.result);
                    convertedData = null;
                    document.getElementById('convert-file-name').textContent = `âœ“ ${file.name}`;
                    document.getElementById('convert-upload-box').classList.add('has-file');
                    document.getElementById('download-btn').disabled = true;
                    
                    analyzeProject();
                } catch (error) {
                    showAlert('convert-result', 'error', 'éŒ¯èª¤ï¼šç„¡æ³•è§£ææª”æ¡ˆï¼' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // åˆ†æå°ˆæ¡ˆ
        function analyzeProject() {
            const isChatflow = convertData.app.mode === 'advanced-chat';
            const nodeCount = convertData.workflow.graph.nodes.length;
            const edgeCount = convertData.workflow.graph.edges.length;

            document.getElementById('node-count').textContent = nodeCount;
            document.getElementById('edge-count').textContent = edgeCount;
            
            const currentType = document.getElementById('current-type');
            const targetType = document.getElementById('target-type');
            
            if (isChatflow) {
                currentType.textContent = 'Chatflow';
                currentType.className = 'type-badge type-chatflow';
                targetType.textContent = 'Workflow';
                targetType.className = 'type-badge type-workflow';
            } else {
                currentType.textContent = 'Workflow';
                currentType.className = 'type-badge type-workflow';
                targetType.textContent = 'Chatflow';
                targetType.className = 'type-badge type-chatflow';
            }

            document.getElementById('convert-info').style.display = 'block';
            document.getElementById('convert-btn').disabled = false;
        }

        // è½‰æ›é¡å‹
        function convertType() {
            if (!convertData) return;

            try {
                convertedData = JSON.parse(JSON.stringify(convertData));
                const isChatflow = convertData.app.mode === 'advanced-chat';

                if (isChatflow) {
                    // Chatflow â†’ Workflow
                    convertedData.app.mode = 'workflow';
                    
                    // æª¢æŸ¥ start ç¯€é»æ˜¯å¦å·²æœ‰ query/message/input è®Šæ•¸
                    const startNode = convertedData.workflow.graph.nodes.find(n => n.data.type === 'start');
                    if (startNode) {
                        // ç¢ºä¿ variables é™£åˆ—å­˜åœ¨
                        if (!startNode.data.variables) {
                            startNode.data.variables = [];
                        }
                        
                        const hasInputVariable = startNode.data.variables.some(v => 
                            v.variable === 'query' || v.variable === 'message' || v.variable === 'input'
                        );
                        
                        // å¦‚æœéƒ½ä¸å­˜åœ¨ï¼Œå»ºç«‹ query è®Šæ•¸ï¼ˆä½¿ç”¨æ­£ç¢ºçš„ Workflow æ ¼å¼ï¼‰
                        if (!hasInputVariable) {
                            startNode.data.variables.push({
                                variable: 'query',
                                label: 'query',
                                type: 'text-input',
                                max_length: 48,
                                default: '',
                                required: true,
                                hint: '',
                                placeholder: '',
                                options: []
                            });
                        }
                    }
                    
                    // è½‰æ› answer ç¯€é»ç‚º end ç¯€é»
                    convertedData.workflow.graph.nodes.forEach(node => {
                        if (node.data.type === 'answer') {
                            node.data.type = 'end';
                            node.type = 'custom';
                            
                            // è½‰æ›è¼¸å‡ºæ ¼å¼
                            if (node.data.answer) {
                                const selector = parseVariableSelector(node.data.answer);
                                node.data.outputs = [{
                                    value_selector: selector,
                                    value_type: 'string',
                                    variable: selector.length > 0 ? selector[selector.length - 1] : 'result'
                                }];
                                delete node.data.answer;
                            } else {
                                // å¦‚æœæ²’æœ‰ answer å±¬æ€§ï¼Œå‰µå»ºä¸€å€‹ç©ºçš„ outputs
                                node.data.outputs = [{
                                    value_selector: [],
                                    value_type: 'string',
                                    variable: 'result'
                                }];
                            }
                            
                            // ç§»é™¤ answer ç¯€é»ç‰¹æœ‰çš„å±¬æ€§ä¸¦è¨­ç½® end ç¯€é»å±¬æ€§
                            delete node.data.variables;
                            
                            // ç¢ºä¿ selected å±¬æ€§å­˜åœ¨
                            if (node.data.selected === undefined) {
                                node.data.selected = false;
                            }
                        }
                    });
                    
                    // è½‰æ› edges ä¸­çš„ targetType å’Œ sourceType
                    convertedData.workflow.graph.edges.forEach(edge => {
                        if (edge.data) {
                            if (edge.data.targetType === 'answer') {
                                edge.data.targetType = 'end';
                            }
                            if (edge.data.sourceType === 'answer') {
                                edge.data.sourceType = 'end';
                            }
                        }
                    });

                    // ç§»é™¤ start ç¯€é»ä¸­çš„ sys.* å…§å»ºåƒæ•¸å¼•ç”¨
                    convertVariableReferences(convertedData, true);

                } else {
                    // Workflow â†’ Chatflow
                    convertedData.app.mode = 'advanced-chat';
                    
                    // è½‰æ› end ç¯€é»ç‚º answer ç¯€é»
                    convertedData.workflow.graph.nodes.forEach(node => {
                        if (node.data.type === 'end') {
                            node.data.type = 'answer';
                            node.type = 'custom';
                            
                            // è½‰æ›è¼¸å‡ºæ ¼å¼
                            if (node.data.outputs && node.data.outputs.length > 0) {
                                const output = node.data.outputs[0];
                                node.data.answer = formatVariableSelector(output.value_selector);
                                delete node.data.outputs;
                            } else {
                                // å¦‚æœæ²’æœ‰ outputsï¼Œå‰µå»ºä¸€å€‹ç©ºçš„ answer
                                node.data.answer = '';
                            }
                            
                            // æ·»åŠ  answer ç¯€é»éœ€è¦çš„å±¬æ€§
                            if (!node.data.variables) {
                                node.data.variables = [];
                            }
                        }
                    });
                    
                    // è½‰æ› edges ä¸­çš„ targetType å’Œ sourceType
                    convertedData.workflow.graph.edges.forEach(edge => {
                        if (edge.data) {
                            if (edge.data.targetType === 'end') {
                                edge.data.targetType = 'answer';
                            }
                            if (edge.data.sourceType === 'end') {
                                edge.data.sourceType = 'answer';
                            }
                        }
                    });

                    // æ·»åŠ  sys.* å…§å»ºåƒæ•¸å¼•ç”¨
                    convertVariableReferences(convertedData, false);
                }

                document.getElementById('download-btn').disabled = false;
                showAlert('convert-result', 'success', 'âœ“ è½‰æ›æˆåŠŸï¼å¯ä»¥ä¸‹è¼‰è½‰æ›å¾Œçš„æª”æ¡ˆã€‚');
            } catch (error) {
                showAlert('convert-result', 'error', 'è½‰æ›å¤±æ•—ï¼š' + error.message);
            }
        }

        // è½‰æ›è®Šæ•¸å¼•ç”¨
        function convertVariableReferences(data, toWorkflow) {
            const convert = (obj) => {
                if (typeof obj === 'string') {
                    if (toWorkflow) {
                        // Chatflow â†’ Workflow: sys.query â†’ query
                        return obj.replace(/\{\{#sys\.query#\}\}/g, '{{#query#}}')
                                  .replace(/sys\.query/g, 'query')
                                  .replace(/\{\{#sys\.dialogue_count#\}\}/g, '')
                                  .replace(/\{\{#sys\.conversation_id#\}\}/g, '');
                    } else {
                        // Workflow â†’ Chatflow: query â†’ sys.query
                        return obj.replace(/\{\{#query#\}\}/g, '{{#sys.query#}}')
                                  .replace(/(?<!sys\.)query(?!_)/g, 'sys.query');
                    }
                } else if (Array.isArray(obj)) {
                    return obj.map(convert);
                } else if (obj && typeof obj === 'object') {
                    const result = {};
                    for (const key in obj) {
                        result[key] = convert(obj[key]);
                    }
                    return result;
                }
                return obj;
            };

            data.workflow.graph.nodes = convert(data.workflow.graph.nodes);
        }

        // è§£æè®Šæ•¸é¸æ“‡å™¨
        function parseVariableSelector(str) {
            const match = str.match(/\{\{#(.+?)#\}\}/);
            if (match) {
                return match[1].split('.');
            }
            return [''];
        }

        // æ ¼å¼åŒ–è®Šæ•¸é¸æ“‡å™¨
        function formatVariableSelector(selector) {
            if (Array.isArray(selector)) {
                return `{{#${selector.join('.')}#}}`;
            }
            return selector;
        }

        // ä¸‹è¼‰è½‰æ›å¾Œçš„æª”æ¡ˆ
        function downloadConverted() {
            if (!convertedData) return;

            const yamlStr = jsyaml.dump(convertedData);
            const isChatflow = convertedData.app.mode === 'advanced-chat';
            const filename = isChatflow ? 'converted_chatflow.yml' : 'converted_workflow.yml';
            
            downloadFile(yamlStr, filename);
        }

        // ä¸‹è¼‰æª”æ¡ˆ
        function downloadFile(content, filename) {
            const blob = new Blob([content], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // é¡¯ç¤ºæç¤º
        function showAlert(elementId, type, message) {
            const alertClass = type === 'success' ? 'alert-success' : type === 'error' ? 'alert-error' : 'alert-info';
            document.getElementById(elementId).innerHTML = 
                `<div class="alert ${alertClass}">${message}</div>`;
        }
    </script>
</body>
</html>